"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8046],{23604:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var r=n(85893),a=n(11151);const i={sidebar_position:1},s="Public Method Types",o={id:"sdk/rust/contract-interface/public-methods",title:"Public Method Types",description:"Methods can be called externally by using the pub identifier within the #[near_bindgen] macro which will expose the method in the compiled WASM bytecode.",source:"@site/i18n/vi/docusaurus-plugin-content-docs/current/sdk/rust/contract-interface/public-methods.md",sourceDirName:"sdk/rust/contract-interface",slug:"/sdk/rust/contract-interface/public-methods",permalink:"/vi/sdk/rust/contract-interface/public-methods",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/sdk/rust/contract-interface/public-methods.md",tags:[],version:"current",lastUpdatedBy:"Github Actions",lastUpdatedAt:1704996595,formattedLastUpdatedAt:"11 thg 1, 2024",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tools",previous:{title:"Collections Nesting",permalink:"/vi/sdk/rust/contract-structure/nesting"},next:{title:"Contract Mutability",permalink:"/vi/sdk/rust/contract-interface/contract-mutability"}},c={},d=[{value:"Exposing trait implementations",id:"exposing-trait-implementations",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,a.a)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"public-method-types",children:"Public Method Types"}),"\n",(0,r.jsxs)(t.p,{children:["Methods can be called externally by using the ",(0,r.jsx)(t.code,{children:"pub"})," identifier within the ",(0,r.jsxs)(t.a,{href:"/vi/sdk/rust/contract-structure/near-bindgen",children:[(0,r.jsx)(t.code,{children:"#[near_bindgen]"})," macro"]})," which will expose the method in the compiled WASM bytecode."]}),"\n",(0,r.jsxs)(t.p,{children:["It is important to only mark methods that should be called externally as public. If you need a contract to call itself, you can mark the function as public but add the ",(0,r.jsxs)(t.a,{href:"/vi/sdk/rust/contract-interface/private-methods",children:[(0,r.jsx)(t.code,{children:"#[private]"})," annotation"]})," so that it will panic if called from anything but the contract itself."]}),"\n",(0,r.jsx)(t.p,{children:"A basic usage of this would look like the following:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"#[near_bindgen]\nimpl MyContractStructure {\n    pub fn some_method(&mut self) {\n        // .. method logic here\n    }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Where this would expose ",(0,r.jsx)(t.code,{children:"some_method"})," from the WASM binary and allow it to be called externally."]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Expand to see generated code"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'#[cfg(target_arch = "wasm32")]\n#[no_mangle]\npub extern "C" fn some_method() {\n    near_sdk::env::setup_panic_hook();\n    if near_sdk::env::attached_deposit() != 0 {\n        near_sdk::env::panic("Method some_method doesn\\\'t accept deposit".as_bytes());\n    }\n    let mut contract: MyContractStructure = near_sdk::env::state_read().unwrap_or_default();\n    contract.some_method();\n    near_sdk::env::state_write(&contract);\n}\n'})})]}),"\n",(0,r.jsx)(t.h2,{id:"exposing-trait-implementations",children:"Exposing trait implementations"}),"\n",(0,r.jsxs)(t.p,{children:["Functions can also be exposed through trait implementations. This can be useful if implementing a shared interface or standard for a contract. This code generation is handled very similarly to basic ",(0,r.jsx)(t.code,{children:"pub"})," functions, but the ",(0,r.jsx)(t.code,{children:"#[near_bindgen]"})," macro only needs to be attached to the trait implementation, not the trait itself:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"pub trait MyTrait {\n    fn trait_method(&mut self);\n}\n\n#[near_bindgen]\nimpl MyTrait for MyContractStructure {\n    fn trait_method(&mut self) {\n        // .. method logic here\n    }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"In this example, the generated code will be the same as the previous example, except with a different method name."}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Expand to see generated code"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'#[cfg(target_arch = "wasm32")]\n#[no_mangle]\npub extern "C" fn trait_method() {\n    near_sdk::env::setup_panic_hook();\n    if near_sdk::env::attached_deposit() != 0 {\n        near_sdk::env::panic("Method trait_method doesn\\\'t accept deposit".as_bytes());\n    }\n    let mut contract: MyContractStructure = near_sdk::env::state_read().unwrap_or_default();\n    contract.trait_method();\n    near_sdk::env::state_write(&contract);\n}\n'})})]})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>s});var r=n(67294);const a={},i=r.createContext(a);function s(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);