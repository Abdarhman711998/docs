"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7566],{59462:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var a=n(85893),i=n(11151);const o={sidebar_position:1},s="near",r={id:"sdk/rust/contract-structure/near-bindgen",title:"near",description:"The #[near] macro is used on a struct and the function implementations to generate the necessary code to be a valid NEAR contract and expose the intended functions to be able to be called externally.",source:"@site/i18n/zh-CN/docusaurus-plugin-content-docs/current/sdk/rust/contract-structure/near-bindgen.md",sourceDirName:"sdk/rust/contract-structure",slug:"/sdk/rust/contract-structure/near-bindgen",permalink:"/zh-CN/sdk/rust/contract-structure/near-bindgen",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/sdk/rust/contract-structure/near-bindgen.md",tags:[],version:"current",lastUpdatedBy:"Github Actions",lastUpdatedAt:1718378911e3,sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tools",previous:{title:"Getting Started",permalink:"/zh-CN/sdk/rust/get-started"},next:{title:"Collections",permalink:"/zh-CN/sdk/rust/contract-structure/collections"}},c={},l=[{value:"Initialization Methods",id:"initialization-methods",level:2},{value:"Payable Methods",id:"payable-methods",level:2},{value:"Private Methods",id:"private-methods",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"near",children:"near"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"#[near]"})," macro is used on a ",(0,a.jsx)(t.code,{children:"struct"})," and the function implementations to generate the necessary code to be a valid NEAR contract and expose the intended functions to be able to be called externally."]}),"\n",(0,a.jsx)(t.p,{children:"For example, on a simple counter contract, the macro will be applied as such:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"use near_sdk::near;\n\n#[near(contract_state)]\n#[derive(Default)]\npub struct Counter {\n    value: u64,\n}\n\n#[near]\nimpl Counter {\n    pub fn increment(&mut self) {\n        self.value += 1;\n    }\n\n    pub fn get_count(&self) -> u64 {\n        self.value\n    }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In this example, the ",(0,a.jsx)(t.code,{children:"Counter"})," struct represents the smart contract state and anything that implements ",(0,a.jsx)(t.code,{children:"BorshSerialize"})," and ",(0,a.jsx)(t.code,{children:"BorshDeserialize"})," can be included, even ",(0,a.jsx)(t.code,{children:"collections"}),", which will be covered in the next section. Whenever a function is called, the state will be loaded and deserialized, so it's important to keep this amount of data loaded as minimal as possible. Whenever a function is called, the state will be loaded and deserialized, so it's important to keep this amount of data loaded as minimal as possible."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"#[near]"})," also annotates the ",(0,a.jsx)(t.code,{children:"impl"})," for ",(0,a.jsx)(t.code,{children:"Counter"})," and this will generate any necessary boilerplate to expose the functions. The core interactions that are important to keep in mind:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Any ",(0,a.jsx)(t.code,{children:"pub"})," functions will be callable externally from any account/contract.","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["For more information, see ",(0,a.jsx)(t.a,{href:"/zh-CN/sdk/rust/contract-interface/public-methods",children:"public methods"})]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"self"})," can be used in multiple ways to control the ",(0,a.jsx)(t.a,{href:"/zh-CN/sdk/rust/contract-interface/contract-mutability",children:"mutability of the contract"}),":","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Functions that take ",(0,a.jsx)(t.code,{children:"&self"})," or ",(0,a.jsx)(t.code,{children:"self"})," will be read-only and do not write the updated state to storage"]}),"\n",(0,a.jsxs)(t.li,{children:["Functions that take ",(0,a.jsx)(t.code,{children:"&mut self"})," allow for mutating state, and state will always be written back at the end of the function call"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["Exposed functions can omit reading and writing to state if ",(0,a.jsx)(t.code,{children:"self"})," is not included in the function params","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"This can be useful for some static functionality or returning data embedded in the contract code"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["If the function has a return value, it will be serialized and attached as a result through ",(0,a.jsx)(t.code,{children:"env::value_return"})]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"initialization-methods",children:"Initialization Methods"}),"\n",(0,a.jsxs)(t.p,{children:["By default, the ",(0,a.jsx)(t.code,{children:"Default::default()"})," implementation of a contract will be used to initialize a contract. By default, the ",(0,a.jsx)(t.code,{children:"Default::default()"})," implementation of a contract will be used to initialize a contract. There can be a custom initialization function which takes parameters or performs custom logic with the following ",(0,a.jsx)(t.code,{children:"#[init]"})," annotation:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:'#[near]\nimpl Counter {\n    #[init]\n    pub fn new(value: u64) -> Self {\n        log!("Custom counter initialization!");\n        Self { value }\n    }\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["All contracts are expected to implement ",(0,a.jsx)(t.code,{children:"Default"}),". All contracts are expected to implement ",(0,a.jsx)(t.code,{children:"Default"}),". If you would like to prohibit the default implementation from being used, the ",(0,a.jsx)(t.code,{children:"PanicOnDefault"})," derive macro can be used:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"#[near(contract_state)]\n#[derive(PanicOnDefault)]\npub struct Counter {\n    // ...\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"payable-methods",children:"Payable Methods"}),"\n",(0,a.jsxs)(t.p,{children:["Methods can be annotated with ",(0,a.jsx)(t.code,{children:"#[payable]"})," to allow tokens to be transferred with the method invocation. For more information, see ",(0,a.jsx)(t.a,{href:"/zh-CN/sdk/rust/contract-interface/payable-methods",children:"payable methods"}),". For more information, see ",(0,a.jsx)(t.a,{href:"/zh-CN/sdk/rust/contract-interface/payable-methods",children:"payable methods"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["To declare a function as payable, use the ",(0,a.jsx)(t.code,{children:"#[payable]"})," annotation as follows:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"#[payable]\npub fn my_method(&mut self) {\n...\n}\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"private-methods",children:"Private Methods"}),"\n",(0,a.jsxs)(t.p,{children:["Some methods need to be exposed to allow the contract to call a method on itself through a promise, but want to disallow any other contract to call it. For this, use the ",(0,a.jsx)(t.code,{children:"#[private]"})," annotation to panic when this method is called externally. See ",(0,a.jsx)(t.a,{href:"/zh-CN/sdk/rust/contract-interface/private-methods",children:"private methods"})," for more information. For this, use the ",(0,a.jsx)(t.code,{children:"#[private]"})," annotation to panic when this method is called externally. See ",(0,a.jsx)(t.a,{href:"/zh-CN/sdk/rust/contract-interface/private-methods",children:"private methods"})," for more information."]}),"\n",(0,a.jsx)(t.p,{children:"This annotation can be applied to any method through the following:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"#[private]\npub fn my_method(&mut self) {\n...\n}\n}\n"})}),"\n",(0,a.jsx)(t.admonition,{title:"Interaction with other macros",type:"info",children:(0,a.jsxs)(t.p,{children:["When ",(0,a.jsx)(t.code,{children:"near"})," is built for the wasm32 target, it generates the external NEAR contract bindings.  To achieve this it is actually generating another function with the signature ",(0,a.jsx)(t.code,{children:'pub extern "C" fn function_name()'})," that first deserializes the contract struct from NEAR storage and then calls the ",(0,a.jsx)(t.code,{children:"contract.function_name(parameter1, parameter2, ...)"}),".  If you have annotated your function with any attribute-like macros, these are then executed ",(0,a.jsx)(t.em,{children:"twice"}),".  Specifically if the attribute like macro makes any modification to the function signature, or inserts any code that depends on the contract struct (in the form of ",(0,a.jsx)(t.code,{children:"&self"}),", ",(0,a.jsx)(t.code,{children:"&mut self"}),", or ",(0,a.jsx)(t.code,{children:"self"}),") this will fail in the second invocation, because the externally exposed function does not have any concept of this struct.  It is possible to detect this by checking which build target you are building for and limit the execution of the macro to operate only on the first pass."]})})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>s});var a=n(67294);const i={},o=a.createContext(i);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);