"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6672],{40494:(t,e,i)=>{i.r(e),i.d(e,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=i(85893),a=i(11151);const o={id:"light-client",title:"Light Client"},l=void 0,s={id:"data-availability/light-client",title:"Light Client",description:"A trustless off-chain light client for NEAR with DA-enabled features, such as KZG commitments, Reed-Solomon erasure coding & storage connectors.",source:"@site/i18n/vi/docusaurus-plugin-content-docs/current/data-availability/light-client.md",sourceDirName:"data-availability",slug:"/data-availability/light-client",permalink:"/vi/data-availability/light-client",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/data-availability/light-client.md",tags:[],version:"current",lastUpdatedBy:"Github Actions",lastUpdatedAt:1704996595,formattedLastUpdatedAt:"11 thg 1, 2024",frontMatter:{id:"light-client",title:"Light Client"},sidebar:"data-availability",previous:{title:"Blob Store Contract",permalink:"/vi/data-availability/blob-contract"},next:{title:"RPC Client",permalink:"/vi/data-availability/rpc"}},r={},c=[];function h(t){const e={li:"li",p:"p",ul:"ul",...(0,a.a)(),...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:"A trustless off-chain light client for NEAR with DA-enabled features, such as KZG commitments, Reed-Solomon erasure coding & storage connectors."}),"\n",(0,n.jsx)(e.p,{children:"The light client provides easy access to transaction and receipt inclusion proofs within a block or chunk.\nThis is useful for checking any dubious blobs which may not have been submitted or validating that a blob has been submitted to NEAR."}),"\n",(0,n.jsx)(e.p,{children:"A blob submission can be verified by:"}),"\n",(0,n.jsxs)(e.ul,{children:["\n",(0,n.jsx)(e.li,{children:"taking the NEAR transaction ID from Ethereum for the blob commitment."}),"\n",(0,n.jsx)(e.li,{children:"Ask the light client for an inclusion proof for the transaction ID or the receipt ID if you're feeling specific; this will give you a Merkle inclusion proof for the transaction/receipt."}),"\n",(0,n.jsx)(e.li,{children:"once you have the inclusion proof, you can ask the light client to verify the proof for you, or advanced users can manually verify it themselves."}),"\n",(0,n.jsx)(e.li,{children:"armed with this knowledge, rollup providers can have advanced integration with light clients and build proving systems around it."}),"\n"]}),"\n",(0,n.jsx)(e.p,{children:"In the future, we will provide extensions to light clients such that non-interactive proofs can be supplied for blob commitments and other data availability features."}),"\n",(0,n.jsx)(e.p,{children:"It's also possible that the light client may be on-chain for the header syncing and inclusion proof verification, but this is a low priority right now."})]})}function d(t={}){const{wrapper:e}={...(0,a.a)(),...t.components};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(h,{...t})}):h(t)}},11151:(t,e,i)=>{i.d(e,{Z:()=>s,a:()=>l});var n=i(67294);const a={},o=n.createContext(a);function l(t){const e=n.useContext(o);return n.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function s(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(a):t.components||a:l(t.components),n.createElement(o.Provider,{value:e},t.children)}}}]);