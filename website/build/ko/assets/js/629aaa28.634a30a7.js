"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1898],{69552:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var s=n(85893),i=n(11151);const o={sidebar_position:1},r="Unit Tests",c={id:"sdk/rust/testing/unit-tests",title:"Unit Tests",description:"Testing contract functionality can be done through the cargo test framework. These tests will run with a mocked blockchain and will allow testing function calls directly without having to set up/deploy to a network and sign serialized transactions on this network.",source:"@site/../docs/sdk/rust/testing/unit-tests.md",sourceDirName:"sdk/rust/testing",slug:"/sdk/rust/testing/unit-tests",permalink:"/ko/sdk/rust/testing/unit-tests",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/sdk/rust/testing/unit-tests.md",tags:[],version:"current",lastUpdatedBy:"Dami\xe1n Parrino",lastUpdatedAt:1661952079,formattedLastUpdatedAt:"2022\ub144 8\uc6d4 31\uc77c",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tools",previous:{title:"Integration Tests",permalink:"/ko/sdk/rust/testing/integration-tests"},next:{title:"Best Practices",permalink:"/ko/sdk/rust/best-practices"}},a={},d=[];function l(t){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",p:"p",pre:"pre",...(0,i.a)(),...t.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,s.jsxs)(e.p,{children:["Testing contract functionality can be done through the ",(0,s.jsx)(e.code,{children:"cargo test"})," framework. These tests will run with a mocked blockchain and will allow testing function calls directly without having to set up/deploy to a network and sign serialized transactions on this network."]}),"\n",(0,s.jsx)(e.p,{children:"A common framework for tests, along with setting up a basic testing environment looks like:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'#[cfg(all(test, not(target_arch = "wasm32")))]\nmod tests {\n    use super::*;\n    use near_sdk::test_utils::VMContextBuilder;\n    use near_sdk::{testing_env, VMContext};\n\n    fn get_context(is_view: bool) -> VMContext {\n        VMContextBuilder::new()\n            .signer_account_id("bob_near".parse().unwrap())\n            .is_view(is_view)\n            .build()\n    }\n\n    #[test]\n    fn my_test() {\n        let context = get_context(false);\n        testing_env!(context);\n        // ... Write test here\n    }\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["Where ",(0,s.jsx)(e.code,{children:"VMContextBuilder"})," allows for modifying the context of the mocked blockchain to simulate the environment that a transaction would be run. The documentation for what can be modified with this context can be found ",(0,s.jsx)(e.a,{href:"https://docs.rs/near-sdk/latest/near_sdk/struct.VMContext.html",children:"here"}),"."]}),"\n",(0,s.jsxs)(e.p,{children:["The ",(0,s.jsx)(e.code,{children:"testing_env!"})," macro will initialize the blockchain interface with the ",(0,s.jsx)(e.code,{children:"VMContext"})," which is either initialized through ",(0,s.jsx)(e.code,{children:"VMContextBuilder"})," or manually through itself."]}),"\n",(0,s.jsx)(e.admonition,{title:"Note",type:"info",children:(0,s.jsxs)(e.p,{children:["This ",(0,s.jsx)(e.code,{children:"testing_env!"})," and ",(0,s.jsx)(e.code,{children:"VMContext"})," is only used for testing outside of ",(0,s.jsx)(e.code,{children:"wasm"})," environments. When running the built contract on a network in a ",(0,s.jsx)(e.code,{children:"wasm"})," environment, the context from the blockchain will be used through host functions on the runtime."]})}),"\n",(0,s.jsxs)(e.p,{children:["To test read-only function calls, set ",(0,s.jsx)(e.code,{children:"is_view"})," to ",(0,s.jsx)(e.code,{children:"true"})," on the ",(0,s.jsx)(e.code,{children:"VMContext"}),". This will test to verify that function calls which just read state do not try to modify state through unit tests. In the above example, ",(0,s.jsx)(e.code,{children:"true"})," should be passed into the ",(0,s.jsx)(e.code,{children:"get_context"})," call, which initializes the context as read-only."]}),"\n",(0,s.jsxs)(e.p,{children:["You will want to use ",(0,s.jsx)(e.code,{children:"testing_env!"})," each time you need to update this context, such as mocking the ",(0,s.jsx)(e.code,{children:"predecessor_accound_id"})," to simulate the functions being called by or only allowing view operations as mentioned above. Each time this is done, a new mocked blockchain will be initialized while keeping the existing state."]})]})}function h(t={}){const{wrapper:e}={...(0,i.a)(),...t.components};return e?(0,s.jsx)(e,{...t,children:(0,s.jsx)(l,{...t})}):l(t)}},11151:(t,e,n)=>{n.d(e,{Z:()=>c,a:()=>r});var s=n(67294);const i={},o=s.createContext(i);function r(t){const e=s.useContext(o);return s.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function c(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:r(t.components),s.createElement(o.Provider,{value:e},t.children)}}}]);