"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3698],{62373:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var n=s(85893),c=s(11151);const r={id:"one-yocto",title:"Ensure it is the User (1y\u24c3)"},o=void 0,a={id:"build/smart-contracts/security/one-yocto",title:"Ensure it is the User (1y\u24c3)",description:"NEAR uses a system of Access Keys to simplify handling accounts.",source:"@site/i18n/zh-CN/docusaurus-plugin-content-docs/current/2.build/2.smart-contracts/security/one_yocto.md",sourceDirName:"2.build/2.smart-contracts/security",slug:"/build/smart-contracts/security/one-yocto",permalink:"/zh-CN/build/smart-contracts/security/one-yocto",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/2.build/2.smart-contracts/security/one_yocto.md",tags:[],version:"current",frontMatter:{id:"one-yocto",title:"Ensure it is the User (1y\u24c3)"},sidebar:"build",previous:{title:"Cross-Contract Calls",permalink:"/zh-CN/build/smart-contracts/security/callbacks"},next:{title:"Sybil Attacks",permalink:"/zh-CN/build/smart-contracts/security/sybil"}},i={},l=[];function d(e){const t={a:"a",code:"code",em:"em",p:"p",strong:"strong",...(0,c.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["NEAR uses a system of ",(0,n.jsx)(t.a,{href:"/zh-CN/concepts/protocol/access-keys",children:"Access Keys"})," to simplify handling accounts.\nThere are basically two type of keys: ",(0,n.jsx)(t.code,{children:"Full Access"}),", that have full control over an account (i.e. can perform all ",(0,n.jsx)(t.a,{href:"../actions.md",children:"actions"}),"), and ",(0,n.jsx)(t.code,{children:"Function Call"}),", that only have permission to call a specified smart contract's method(s) that ",(0,n.jsx)(t.em,{children:"do not"})," attach \u24c3 as a deposit."]}),"\n",(0,n.jsxs)(t.p,{children:["When a user ",(0,n.jsx)(t.a,{href:"../../integrate/frontend.md#user-sign-in",children:"signs in on a website"})," to interact with your contract, what actually happens is that a ",(0,n.jsx)(t.code,{children:"Function Call"})," key is created and stored in the website. Since the website has access to the ",(0,n.jsx)(t.code,{children:"Function Call"})," key, it can use it to call the authorized methods as it pleases. While this is very user friendly for most cases, it is important to be careful in scenarios involving transferring of valuable assets like ",(0,n.jsx)(t.a,{href:"../../relevant-contracts/nft.md",children:"NFTs"})," or ",(0,n.jsx)(t.a,{href:"../../relevant-contracts/ft.md",children:"FTs"}),". In such cases, you need to ensure that the person asking for the asset to be transfer is ",(0,n.jsx)(t.strong,{children:"actually the user"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["One direct and inexpensive way to ensure that the user is the one calling is by requiring to attach ",(0,n.jsx)(t.code,{children:"1 y\u24c3"}),". In this case, the user will be redirected to the wallet and be asked to accept the transaction. This is because, once again, only the ",(0,n.jsx)(t.code,{children:"Full Access"})," key can be used to send NEAR.\nSince the ",(0,n.jsx)(t.code,{children:"Full Access"})," key is only in the user's wallet, you can trust that a transaction with ",(0,n.jsx)(t.code,{children:"1 y\u24c3"})," was made by the user."]})]})}function u(e={}){const{wrapper:t}={...(0,c.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>a,a:()=>o});var n=s(67294);const c={},r=n.createContext(c);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);