"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7192],{86551:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var n=i(85893),a=i(11151);const s={id:"light-client",title:"Light Client"},r="NEAR light client",l={id:"data-availability/light-client",title:"Light Client",description:"A trustless off-chain light client for NEAR with DA-enabled features, such as KZG commitments, Reed-Solomon erasure coding & storage connectors.",source:"@site/../docs/data-availability/light-client.md",sourceDirName:"data-availability",slug:"/data-availability/light-client",permalink:"/data-availability/light-client",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/data-availability/light-client.md",tags:[],version:"current",lastUpdatedBy:"Dami\xe1n Parrino",lastUpdatedAt:1711026111,formattedLastUpdatedAt:"Mar 21, 2024",frontMatter:{id:"light-client",title:"Light Client"},sidebar:"data-availability",previous:{title:"Blob Store Contract",permalink:"/data-availability/blob-contract"},next:{title:"RPC Client",permalink:"/data-availability/rpc"}},o={},c=[{value:"Features",id:"features",level:2},{value:"Blob verification",id:"blob-verification",level:2},{value:"Implementations",id:"implementations",level:2},{value:"Off-chain client",id:"off-chain-client",level:3},{value:"State",id:"state",level:4},{value:"Interface",id:"interface",level:4},{value:"ZK client",id:"zk-client",level:3},{value:"Circuits",id:"circuits",level:4},{value:"Sync",id:"sync",level:5},{value:"Verify",id:"verify",level:5}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"near-light-client",children:"NEAR light client"}),"\n",(0,n.jsx)(t.p,{children:"A trustless off-chain light client for NEAR with DA-enabled features, such as KZG commitments, Reed-Solomon erasure coding & storage connectors."}),"\n",(0,n.jsx)(t.h2,{id:"features",children:"Features"}),"\n",(0,n.jsx)(t.p,{children:"A fully featured, injectable, dependable implementation of the NEAR light client protocol."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Injectable"}),": Interoperability with dependencies is very hard to maintain and eventually falls by the wayside.\nWith the light client being injectable, developers can inject cryptographic semantics and the light client logic should be the same, with the only difference being what environment the application uses."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Robust"}),": With an open source, contributor-friendly effort, stringent semantic versioning and audits, we can be sure that the light client will be robust and maintainable."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Dependable"}),": The Protocol itself should not be dependent on many dependencies which would detract from its usability. Ideally, the light client should be ",(0,n.jsx)(t.code,{children:"#[no_std]"}),", and it should be environment-agnostic."]}),"\n"]}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsxs)(t.p,{children:["To learn more, check the ",(0,n.jsx)(t.a,{href:"https://nomicon.io/ChainSpec/LightClient",children:"Near light client specification"}),"."]})}),"\n",(0,n.jsx)(t.h2,{id:"blob-verification",children:"Blob verification"}),"\n",(0,n.jsx)(t.p,{children:"The light client provides easy access to transaction and receipt inclusion proofs within a block or chunk.\nThis is useful for checking any dubious blobs which may not have been submitted or validating that a blob has been submitted to NEAR."}),"\n",(0,n.jsx)(t.p,{children:"A blob submission can be verified by:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"taking the NEAR transaction ID from Ethereum for the blob commitment."}),"\n",(0,n.jsx)(t.li,{children:"Ask the light client for an inclusion proof for the transaction ID or the receipt ID if you're feeling specific; this will give you a Merkle inclusion proof for the transaction/receipt."}),"\n",(0,n.jsx)(t.li,{children:"once you have the inclusion proof, you can ask the light client to verify the proof for you, or advanced users can manually verify it themselves."}),"\n",(0,n.jsx)(t.li,{children:"armed with this knowledge, rollup providers can have advanced integration with light clients and build proving systems around it."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"implementations",children:"Implementations"}),"\n",(0,n.jsxs)(t.p,{children:["At present, there are currently two implementations of the light client. The ",(0,n.jsx)(t.code,{children:"std"})," and the ",(0,n.jsx)(t.code,{children:"zk"})," version."]}),"\n",(0,n.jsx)(t.h3,{id:"off-chain-client",children:"Off-chain client"}),"\n",(0,n.jsx)(t.p,{children:"This is the first light client that was used to build on the logic of the protocol, it has the greatest environment assumptions and a bunch of dependencies."}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.a,{href:"https://github.com/near/near-light-client/tree/master/bin/client",children:"off-chain light client"}),", which syncs with the final head of the chain, applies the sync protocol and stores the block producers and the next header.\nThis is the most basic way to run the light client, you can configure the ",(0,n.jsx)(t.code,{children:"${ENVIRONMENT}.toml"})," to set your trusted checkpoints, state and the host exposed and this will work out of the box, syncing with the state and catching up if needed."]}),"\n",(0,n.jsx)(t.h4,{id:"state",children:"State"}),"\n",(0,n.jsxs)(t.p,{children:["It also stores some information in the state database. This contains a few tries in ",(0,n.jsx)(t.code,{children:"sled"}),", namely block producers, headers and any cachable information used for verification."]}),"\n",(0,n.jsx)(t.h4,{id:"interface",children:"Interface"}),"\n",(0,n.jsxs)(t.p,{children:["It exposes an HTTP interface for querying state and providing proofs.\nIt exposes a JSON-RPC implementation to be more compatible with users already aware of ",(0,n.jsx)(t.a,{href:"/api/rpc/introduction",children:"NEAR RPC"})," nodes."]}),"\n",(0,n.jsx)(t.h3,{id:"zk-client",children:"ZK client"}),"\n",(0,n.jsx)(t.p,{children:"It's a fully featured light client protocol, providing sync and transaction verification. It exploits STARK acceleration for the STARK-friendly functionality and parallel proving for the Merkle verification.\nWe aim to also fold verification and syncing with proof recursion so the light client can act lazily, syncing when needed, vs syncing eagerly."}),"\n",(0,n.jsx)(t.admonition,{type:"tip",children:(0,n.jsxs)(t.p,{children:["Check out the ZK light client on the ",(0,n.jsx)(t.a,{href:"https://alpha.succinct.xyz/near/near-light-client",children:"Succinct network here"}),"."]})}),"\n",(0,n.jsxs)(t.p,{children:["The initial implementation of the ZK light client protocol can be ",(0,n.jsx)(t.a,{href:"https://github.com/near/near-light-client/tree/master/nearx",children:"found here"}),". It leverages ",(0,n.jsx)(t.a,{href:"https://alpha.succinct.xyz/",children:"Succinct's prover network"})," and ",(0,n.jsx)(t.a,{href:"https://github.com/succinctlabs/succinctx",children:"plonky2x SDK"})," as a proving system.\nThis will allow developers to pay for proof generation from the proof market."]}),"\n",(0,n.jsx)(t.h4,{id:"circuits",children:"Circuits"}),"\n",(0,n.jsx)(t.p,{children:"Below are the current circuits for the ZK light client."}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsx)(t.p,{children:'The current circuits serve only a "one-shot" command style for syncing/verification and no autonomous proving.'})}),"\n",(0,n.jsx)(t.p,{children:"Since the ZK client integrates with a Solidity Contract on chain and the circuit must have a statically aligned size, we have to minimize as much call data as possible, opting to witness verification in the circuit rather than store information."}),"\n",(0,n.jsx)(t.h5,{id:"sync",children:"Sync"}),"\n",(0,n.jsxs)(t.p,{children:["Syncs to the next ",(0,n.jsx)(t.code,{children:"head"}),", either the last header of the next epoch or the next header in the current epoch."]}),"\n",(0,n.jsx)(t.p,{children:"Public inputs:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"trusted_header_hash"}),": This is the last header that was synced or the checkpoint header. We use this to query the header info and witness the header is valid, as well as to ensure the header was once synced."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Public Outputs:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"next_header_hash"}),": The header hash of the next header that has been synced in the protocol."]}),"\n"]}),"\n",(0,n.jsx)(t.h5,{id:"verify",children:"Verify"}),"\n",(0,n.jsx)(t.p,{children:"Verifies a batch of transactions/receipts, this wraps the Merkle proof verification of multiple transactions in a parallelised circuit.\nThis allows us to witness the verification of arbitrary amounts of transactions and only pay for verification on Ethereum once, with the relay of the results for the transactions/receipts calldata being the most fees."}),"\n",(0,n.jsx)(t.p,{children:"Public inputs:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"trusted_header_hash"}),": The last header that was synced. We can use this to also determine if we need to sync in this verification. And to query the header information."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"transaction_or_receipt_ids"}),": The transactions or receipts to be verified."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Public Outputs:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"transaction_or_receipt_results"}),": The IDs and the result of their verification"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},11151:(e,t,i)=>{i.d(t,{Z:()=>l,a:()=>r});var n=i(67294);const a={},s=n.createContext(a);function r(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);