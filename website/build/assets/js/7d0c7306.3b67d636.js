"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[153],{84197:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>l});var s=t(85893),i=t(11151);const c={id:"overview",title:"Transactions",sidebar_label:"Overview"},o=void 0,a={id:"concepts/basics/transactions/overview",title:"Transactions",description:"NEAR is asynchronous by design. While it opens a wide range of possibilities for smart contracts implementations, it may also add to confusion among beginners and newcomers from other blockchain platforms.",source:"@site/../docs/1.concepts/basics/transactions/overview.md",sourceDirName:"1.concepts/basics/transactions",slug:"/concepts/basics/transactions/overview",permalink:"/concepts/basics/transactions/overview",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/1.concepts/basics/transactions/overview.md",tags:[],version:"current",lastUpdatedBy:"gagdiez",lastUpdatedAt:1702155614,formattedLastUpdatedAt:"Dec 9, 2023",frontMatter:{id:"overview",title:"Transactions",sidebar_label:"Overview"},sidebar:"concepts",previous:{title:"Creating Accounts",permalink:"/concepts/basics/accounts/creating-accounts"},next:{title:"Gas",permalink:"/concepts/basics/transactions/gas"}},r={},l=[{value:"Transaction",id:"transaction",level:2},{value:"Action",id:"action",level:2},{value:"Receipt",id:"receipt",level:2},{value:"Transaction Atomicity",id:"atomicity",level:2},{value:"Transaction Status",id:"transaction-status",level:2},{value:"Finality",id:"finality",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"NEAR is asynchronous by design. While it opens a wide range of possibilities for smart contracts implementations, it may also add to confusion among beginners and newcomers from other blockchain platforms.\nTransactions in NEAR may contain actions that do asynchronous work, in such cases keep in mind the possible outcomes of success or failure of the transaction. For example, if a transaction contains a cross-contract call, it may be marked as successful, but the other contract execution might fail. This article covers possible scenarios for this."}),"\n",(0,s.jsxs)(n.p,{children:['A transaction is the smallest unit of work that can be assigned to the network. "Work" in this case means compute (executing a function) or storage (reading/writing data). A transaction is composed of one or more ',(0,s.jsx)(n.code,{children:"Action"}),'s. A transaction with more than one action is referred to as a "batch transaction". Since transactions are the smallest units of work, they are also atomic, but again, asynchronous actions do not necessarily cascade their success or failure the whole transaction.']}),"\n",(0,s.jsxs)(n.p,{children:["There is also a concept of ",(0,s.jsx)(n.code,{children:"Receipt"}),', which is either "request to apply an ',(0,s.jsx)(n.code,{children:"Action"}),'" or "result of the ',(0,s.jsx)(n.code,{children:"Action"}),"\". All cross-contract communication is done through receipts. An action may result in one or more receipts. The Blockchain may be seen as a series of Transactions, but it's also a series of Receipts."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)("a",{href:"https://nearblocks.io/",children:"NEAR Blockchain Explorer"})," to inspect and see all actions and receipts related to a transaction."]})}),"\n",(0,s.jsxs)(n.p,{children:["An in depth documentation about transactions can be found in ",(0,s.jsx)(n.a,{href:"https://nomicon.io/RuntimeSpec/Transactions",children:"NEAR Protocol Specifications (nomicon.io)"}),".\nOn this page we give an overview of the important aspects of transactions on NEAR."]}),"\n",(0,s.jsx)(n.h2,{id:"transaction",children:"Transaction"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"Transaction"})," is a collection of ",(0,s.jsx)(n.code,{children:"Actions"})," that describe what should be done at the destination (the ",(0,s.jsx)(n.code,{children:"receiver"})," account)."]}),"\n",(0,s.jsxs)(n.p,{children:["Each ",(0,s.jsx)(n.code,{children:"Transaction"})," is augmented with critical information about its:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"origin"})," (cryptographically signed by ",(0,s.jsx)(n.code,{children:"signer"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"destination"})," or intention (sent or applied to ",(0,s.jsx)(n.code,{children:"receiver"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"recency"})," (",(0,s.jsx)(n.code,{children:"block_hash"})," from recent block within acceptable limits - ",(0,s.jsx)(n.a,{href:"/concepts/basics/epoch",children:"1 epoch"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"uniqueness"})," (",(0,s.jsx)(n.code,{children:"nonce"})," must be unique for a given ",(0,s.jsx)(n.code,{children:"signer"})," ",(0,s.jsx)(n.code,{children:"AccessKey"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"action",children:"Action"}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.code,{children:"Action"})," is a composable unit of operation that, together with zero or more other ",(0,s.jsx)(n.code,{children:"Actions"}),", defines a sensible ",(0,s.jsx)(n.code,{children:"Transaction"}),". There are currently 8 supported ",(0,s.jsx)(n.code,{children:"Action"})," types:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FunctionCall"})," to invoke a method on a contract (and optionally attach a budget for compute and storage)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Transfer"})," to move tokens from between accounts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DeployContract"})," to deploy a contract"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CreateAccount"})," to make a new account (for a person, contract, refrigerator, etc.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DeleteAccount"})," to delete an account (and transfer the balance to a beneficiary account)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AddKey"})," to add a key to an account (either ",(0,s.jsx)(n.code,{children:"FullAccess"})," or ",(0,s.jsx)(n.code,{children:"FunctionCall"})," access)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DeleteKey"})," to delete an existing key from an account"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Stake"})," to express interest in becoming a validator at the next available opportunity"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["You can find more about the technical details of ",(0,s.jsx)(n.code,{children:"Action"}),"s in the ",(0,s.jsx)(n.a,{href:"https://nomicon.io/RuntimeSpec/Actions",children:"NEAR nomicon"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"receipt",children:"Receipt"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"Receipt"}),' is the only actionable object in the system. Therefore, when we talk about "processing a transaction" on the NEAR platform, this eventually means "applying receipts" at some point.']}),"\n",(0,s.jsxs)(n.p,{children:["A good mental model is to think of a ",(0,s.jsx)(n.code,{children:"Receipt"})," as a paid message to be executed at the destination (",(0,s.jsx)(n.code,{children:"receiver"}),"). And a ",(0,s.jsx)(n.code,{children:"Transaction"})," is an externally issued request to create the ",(0,s.jsx)(n.code,{children:"Receipt"})," (there is a 1-to-1 relationship)."]}),"\n",(0,s.jsxs)(n.p,{children:["There are several ways of creating ",(0,s.jsx)(n.code,{children:"Receipts"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["issuing a ",(0,s.jsx)(n.code,{children:"Transaction"})]}),"\n",(0,s.jsx)(n.li,{children:"returning a promise (related to cross-contract calls)"}),"\n",(0,s.jsx)(n.li,{children:"issuing a refund"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["You can find more about the technical details of ",(0,s.jsx)(n.code,{children:"Receipts"})," in the ",(0,s.jsx)(n.a,{href:"https://nomicon.io/RuntimeSpec/Receipts",children:"NEAR nomicon"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"atomicity",children:"Transaction Atomicity"}),"\n",(0,s.jsx)(n.p,{children:"Since transactions are converted to receipts before they are applied, it suffices to talk about receipt atomicity.\nReceipt execution is atomic, meaning that either all the actions are successfully executed or none are.\nHowever, one caveat is that a function call transaction, unlike other transactions, can spawn an indefinite amount of receipts, and while each receipt is atomic, the success or failure of one receipt doesn't necessarily affect the status of other receipts spawned by the same transaction."}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"When designing a smart contract, you should always consider the asynchronous nature of NEAR Protocol."})}),"\n",(0,s.jsx)(n.h2,{id:"transaction-status",children:"Transaction Status"}),"\n",(0,s.jsxs)(n.p,{children:["You can query the status of a transaction through ",(0,s.jsx)(n.a,{href:"/api/rpc/setup",children:"RPC API"})," or ",(0,s.jsx)(n.a,{href:"https://docs.near.org/tools/near-cli#near-tx-status",children:"NEAR CLI"}),". An example of the query result looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{\n  status: { SuccessValue: '' },\n  transaction: {\n    actions: [ { Transfer: { deposit: '50000000000000000000000' } } ],\n    hash: '54sZqhqvwynMmMEcN7LcNLxUjx2o5xyFn2FC4zkpNUas',\n    nonce: 64986174290372,\n    public_key: 'ed25519:EDPw6PkPetebJvrp1jtcvknCGeFguf7LrSGFCRqLrXks',\n    receiver_id: '1167fc268181c9ee30e914016d2148b4b7fdc0dc2d70e2a29df9c65756b52116',\n    signature: 'ed25519:52mSUmSBCXe1fF2m6cWbhQPUFuKz965aWCP6Aa4Jaaf1Kr93wDfJ8DKwkCUhEdahqJuDNNcMqDP2qjX5Xb1XRvsf',\n    signer_id: 'sweat_welcome.near'\n  },\n  transaction_outcome: {\n    block_hash: 'BS5ongkXQgcqFuH8xbJBfLVjF8fGhVip3wogi5f1SxpN',\n    id: '54sZqhqvwynMmMEcN7LcNLxUjx2o5xyFn2FC4zkpNUas',\n    outcome: {\n      executor_id: 'sweat_welcome.near',\n      gas_burnt: 4174947687500,\n      logs: [],\n      metadata: { gas_profile: null, version: 1 },\n      receipt_ids: [ '6WGRhQyaxzKyMW1YaMiPpbH5u2QYM7hMFrkbW38guY9D' ],\n      status: {\n        SuccessReceiptId: '6WGRhQyaxzKyMW1YaMiPpbH5u2QYM7hMFrkbW38guY9D'\n      },\n      tokens_burnt: '417494768750000000000'\n    },\n    \"proof\": []\n  },\n  receipts_outcome: [\n    {\n      block_hash: 'GGeKQ2GZoQffwef5oA4bRjYes7Cwp8fn3qiwo5ZpVKiN',\n      id: '6WGRhQyaxzKyMW1YaMiPpbH5u2QYM7hMFrkbW38guY9D',\n      outcome: {\n        executor_id: '1167fc268181c9ee30e914016d2148b4b7fdc0dc2d70e2a29df9c65756b52116',\n        gas_burnt: 4174947687500,\n        logs: [],\n        metadata: { gas_profile: [], version: 3 },\n        receipt_ids: [ '5m6D2DxLX3A59cAMZJmd6iTkYqL3QEE3Cr2FnXwzzvSr' ],\n        status: { SuccessValue: '' },\n        tokens_burnt: '417494768750000000000'\n      },\n      \"proof\": []\n    },\n    {\n      block_hash: 'A9vaFWg9Dv9tSvtQxf8j2mna4hV3UUG6wzNqjVferp57',\n      id: '5m6D2DxLX3A59cAMZJmd6iTkYqL3QEE3Cr2FnXwzzvSr',\n      outcome: {\n        executor_id: 'sweat_welcome.near',\n        gas_burnt: 223182562500,\n        logs: [],\n        metadata: { gas_profile: [], version: 3 },\n        receipt_ids: [],\n        status: { SuccessValue: '' },\n        tokens_burnt: '0'\n      },\n      \"proof\": []\n    }\n  ]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The query result displays:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"the overall status of the transaction,"}),"\n",(0,s.jsx)(n.li,{children:"the outcomes of the transaction,"}),"\n",(0,s.jsx)(n.li,{children:"and the outcome of the receipts generated by this transaction."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"status"})," field appears at:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"the top-level, where it indicates whether all actions in the transaction have been successfully executed,"}),"\n",(0,s.jsxs)(n.li,{children:["under ",(0,s.jsx)(n.code,{children:"transaction_outcome"}),", where it indicates whether the transaction has been successfully converted to a receipt,"]}),"\n",(0,s.jsxs)(n.li,{children:["under ",(0,s.jsx)(n.code,{children:"receipts_outcome"})," for each receipt, where it indicates whether the receipt has been successfully executed."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"status"})," is an object with a single key, one of the following four:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"status: { SuccessValue: 'val or empty'}"})," - the receipt or transaction has been successfully executed. If it's the result of a function call receipt, the value is the return value of the function, otherwise the value is empty."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"status: { SuccessReceiptId: 'id_of_generated_receipt' }"})," - either a transaction has been successfully converted to a receipt, or a receipt is successfully processed and generated another receipt. The value of this key is the id of the newly generated receipt."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"status: { Failure: {} }'"})," - transaction or receipt has failed during execution. The value will include error reason."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"status: { Unknown: '' }'"})," - the transaction or receipt hasn't been processed yet."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["For receipts, ",(0,s.jsx)(n.code,{children:"SuccessValue"})," and ",(0,s.jsx)(n.code,{children:"SuccessReceiptId"})," come from the last action's execution. The results of other action executions in the same receipt are not returned. However, if any action fails, the receipt's execution stops, and the failure is returned, meaning that ",(0,s.jsx)(n.code,{children:"status"})," would be ",(0,s.jsx)(n.code,{children:"Failure"}),". And if the last action is not a function call and it's successfully executed, the result will be an empty ",(0,s.jsx)(n.code,{children:"SuccessValue"})]})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["For receipts, The last receipt in the list is the ",(0,s.jsx)(n.code,{children:"refund"})," receipt. Refund receipts do not actually cost any ",(0,s.jsx)(n.code,{children:"gas"}),", but they still count the gas towards the block gas. In this case, the refund receipt is ",(0,s.jsx)(n.code,{children:"5m6D2DxLX3A59cAMZJmd6iTkYqL3QEE3Cr2FnXwzzvSr"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["The top-level ",(0,s.jsx)(n.code,{children:"status"})," indicates whether all actions in the transaction have been successfully executed. However, one caveat is that the successful execution of the function call does not necessarily mean that the receipts spawned from the function call are all successfully executed."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub fn transfer(receiver_id: String) {\n    Promise::new(receiver_id).transfer(10);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This function schedules a promise, but its return value is unrelated to that promise. So even if the promise fails, potentially because ",(0,s.jsx)(n.code,{children:"receiver_id"})," does not exist, a transaction that calls this function will still have ",(0,s.jsx)(n.code,{children:"SuccessValue"})," in the overall ",(0,s.jsx)(n.code,{children:"status"}),". You can check the status of each of the receipts generated by going through ",(0,s.jsx)(n.code,{children:"receipt_outcomes"})," in the same query result."]}),"\n",(0,s.jsx)(n.h2,{id:"finality",children:"Finality"}),"\n",(0,s.jsx)(n.p,{children:"Transaction finality is closely tied to the finality of the block in which the transaction is included.\nHowever, they are not necessarily the same because often, one is concerned with whether the receipts, not the transaction itself, are final since receipt execution is where most of the work is done. Therefore, to verify the finality of a transaction, you can query the transaction and check if all the block hashes of the transactions and receipts generated from the transaction are final."}),"\n",(0,s.jsx)(n.admonition,{title:"Got a question?",type:"tip",children:(0,s.jsx)("a",{href:"https://stackoverflow.com/questions/tagged/nearprotocol",children:" Ask it on StackOverflow! "})})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>o});var s=t(67294);const i={},c=s.createContext(i);function o(e){const n=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);