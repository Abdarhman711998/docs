"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4817],{82071:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>c,metadata:()=>o,toc:()=>l});var r=e(85893),a=e(11151);const c={id:"smart-contract",title:"Smart Contract",hide_table_of_contents:!1},i=void 0,o={id:"primitives/nft/interacting/smart-contract",title:"Smart Contract",description:"This section will explain how a smart contract can mint, buy, transfer and query NFTs.",source:"@site/i18n/ko/docusaurus-plugin-content-docs/current/7.primitives/nft/interacting/smart-contract.md",sourceDirName:"7.primitives/nft/interacting",slug:"/primitives/nft/interacting/smart-contract",permalink:"/ko/primitives/nft/interacting/smart-contract",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/7.primitives/nft/interacting/smart-contract.md",tags:[],version:"current",lastUpdatedBy:"Github Actions",lastUpdatedAt:1704996595,formattedLastUpdatedAt:"2024\ub144 1\uc6d4 11\uc77c",frontMatter:{id:"smart-contract",title:"Smart Contract",hide_table_of_contents:!1},sidebar:"primitives",previous:{title:"Web Application",permalink:"/ko/primitives/nft/interacting/web-app"},next:{title:"NEAR CLI",permalink:"/ko/primitives/nft/interacting/near-cli"}},s={},l=[{value:"Base Contract",id:"base-contract",level:3},{value:"Mint a NFT",id:"mint-a-nft",level:2},{value:"Buy a NFT",id:"buy-a-nft",level:2},{value:"Query NFT data",id:"query-nft-data",level:2},{value:"Transfer a NFT",id:"transfer-a-nft",level:2},{value:"List a NFT for sale",id:"list-a-nft-for-sale",level:2},{value:"Additional resources",id:"additional-resources",level:2}];function d(n){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,a.a)(),...n.components},{Details:e}=t;return e||function(n,t){throw new Error("Expected "+(t?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"This section will explain how a smart contract can mint, buy, transfer and query NFTs."}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["If you are looking to create your own NFT contract please check the ",(0,r.jsx)(t.a,{href:"https://github.com/near-examples/NFT",children:"Example implementation"})," and the ",(0,r.jsx)(t.a,{href:"https://docs.near.org/tutorials/nfts/introduction",children:"NFT Zero to Hero Tutorial"})]})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h3,{id:"base-contract",children:"Base Contract"}),"\n",(0,r.jsx)(t.p,{children:"The examples assume that the contract is defined as follows:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'use near_contract_standards::non_fungible_token::{Token, TokenId};\nuse near_sdk::ext_contract;\nuse near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::{env, log, near_bindgen, AccountId, Promise, PromiseError};\n\nconst NFT_CONTRACT: &str = "x.paras.near";\n\n// Define the contract structure\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct Contract {\n  nft_contract: AccountId\n}\n\nimpl Default for Contract {\n    // The default trait with which to initialize the contract\n    fn default() -> Self {\n        Self {\n          nft_contract: NFT_CONTRACT.parse().unwrap(),\n        }\n    }\n}\n\n// Implement the contract structure\n#[near_bindgen]\nimpl Contract {}\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"mint-a-nft",children:"Mint a NFT"}),"\n",(0,r.jsxs)(e,{children:[(0,r.jsx)("summary",{children:(0,r.jsx)(t.p,{children:"Minting in Paras"})}),(0,r.jsxs)(t.p,{children:["In case with Paras NFT contract before minting NFT token you may need to create token series from your contract account. You can do it via ",(0,r.jsx)(t.a,{href:"https://paras.id/en",children:"Paras UI"})," or use ",(0,r.jsx)(t.code,{children:"near-cli"}),":"]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:'# Example of the command creating token series on Paras\nnear call x.paras.near nft_create_series \'{"token_metadata": {"title": "NFT #1", "media": "bafybeibnpe5x6euhjtn5qrayfgeemxyru7ho3yhdyaifv7gsvdn46j6vzi", "reference": "bafybeif6cjn5bmdp7w5x2jms2xlz64qmp7crd5z77rl3iy3m54mlustdiu", "copies": 10}, "royalty": {"<YOUR_CONTRACT_ADDRESS>": 1000}, "price": null}\' --accountId <YOUR_CONTRACT_ADDRESS> --depositYocto 6090000000000000000000\n'})})]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'// Validator interface, for cross-contract calls\n#[ext_contract(ext_nft_contract)]\ntrait ExternalNftContract {\n  fn nft_mint(&self, token_series_id: String, receiver_id: AccountId) -> Promise;\n}\n\n// Implement the contract structure\n#[near_bindgen]\nimpl Contract {\n  #[payable]\n  pub fn nft_mint(&mut self, token_series_id: String, receiver_id: AccountId) -> Promise {\n    let promise = ext_nft_contract::ext(self.nft_contract.clone())\n      .with_static_gas(Gas(30*TGAS))\n      .with_attached_deposit(env::attached_deposit())\n      .nft_mint(token_series_id, receiver_id);\n\n    return promise.then( // Create a promise to callback query_greeting_callback\n      Self::ext(env::current_account_id())\n      .with_static_gas(Gas(30*TGAS))\n      .nft_mint_callback()\n    )\n  }\n\n  #[private] // Public - but only callable by env::current_account_id()\n  pub fn nft_mint_callback(&self, #[callback_result] call_result: Result<TokenId, PromiseError>) -> Option<TokenId> {\n    // Check if the promise succeeded\n    if call_result.is_err() {\n      log!("There was an error contacting NFT contract");\n      return None;\n    }\n\n    // Return the token data\n    let token_id: TokenId = call_result.unwrap();\n    return Some(token_id);\n  }\n}\n'})}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsx)(t.p,{children:"Values of gas and deposit might vary depending on which NFT contract you are calling."})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"buy-a-nft",children:"Buy a NFT"}),"\n",(0,r.jsx)(t.p,{children:"This is an example on how you can make your smart contract buy a NFT on some marketplace (Paras this case)."}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsx)(t.p,{children:"Please note that in this example the contract will be the owner of the NFT, however, some marketplaces allow you to buy NFT for somebody else."})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'const NFT_MARKETPLACE_CONTRACT: &str = "paras-marketplace-v2.testnet";\n\n// Define the contract structure\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct Contract {\n  nft_marketplace_contract: AccountId\n}\n\nimpl Default for Contract {\n    // The default trait with which to initialize the contract\n    fn default() -> Self {\n        Self {\n          nft_marketplace_contract: NFT_MARKETPLACE_CONTRACT.parse().unwrap()\n        }\n    }\n}\n\n// Validator interface, for cross-contract calls\n#[ext_contract(ext_nft_contract)]\ntrait ExternalNftContract {\n  fn buy(&self, nft_contract_id: AccountId, token_id: TokenId, ft_token_id: Option<AccountId>, price: Option<U128>) -> Promise;\n}\n\n// Implement the contract structure\n#[near_bindgen]\nimpl Contract {\n  #[payable]\n  pub fn buy(&mut self, nft_contract_id: AccountId, token_id: TokenId, ft_token_id: Option<AccountId>, price: Option<U128>) -> Promise {\n    let promise = ext_nft_contract::ext(self.nft_marketplace_contract.clone())\n      .with_static_gas(Gas(30*TGAS))\n      .with_attached_deposit(env::attached_deposit())\n      .buy(nft_contract_id, token_id, ft_token_id, price);\n\n    return promise.then( // Create a promise to callback query_greeting_callback\n      Self::ext(env::current_account_id())\n      .with_static_gas(Gas(30*TGAS))\n      .buy_callback()\n    )\n  }\n\n  #[private] // Public - but only callable by env::current_account_id()\n  pub fn buy_callback(&self, #[callback_result] call_result: Result<(), PromiseError>) {\n    // Check if the promise succeeded\n    if call_result.is_err() {\n      log!("There was an error contacting NFT contract");\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"query-nft-data",children:"Query NFT data"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'// Validator interface, for cross-contract calls\n#[ext_contract(ext_nft_contract)]\ntrait ExternalNftContract {\n  fn nft_token(&self, token_id: TokenId) -> Promise;\n}\n\n// Implement the contract structure\n#[near_bindgen]\nimpl Contract {\n  pub fn nft_token(&self, token_id: TokenId) -> Promise {\n    let promise = ext_nft_contract::ext(self.nft_contract.clone())\n      .nft_token(token_id);\n\n    return promise.then( // Create a promise to callback query_greeting_callback\n      Self::ext(env::current_account_id())\n      .nft_token_callback()\n    )\n  }\n\n  #[private] // Public - but only callable by env::current_account_id()\n  pub fn nft_token_callback(&self, #[callback_result] call_result: Result<Token, PromiseError>) -> Option<Token> {\n    // Check if the promise succeeded\n    if call_result.is_err() {\n      log!("There was an error contacting NFT contract");\n      return None;\n    }\n\n    // Return the token data\n    let token_data: Token = call_result.unwrap();\n    return Some(token_data);\n  }\n}\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"transfer-a-nft",children:"Transfer a NFT"}),"\n",(0,r.jsx)(t.p,{children:"This is how a contract can transfer an NFT."}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsx)(t.p,{children:"Please notice that a contract can only transfer an NFT that they own, or an NFT that they were approved to transfer."})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'const YOCTO_NEAR: u128 = 1;\n\n#[ext_contract(ext_nft_contract)]\ntrait ExternalNftContract {\n  fn nft_transfer(&self, receiver_id: AccountId, token_id: TokenId) -> Promise;\n}\n\nimpl Contract {\n  #[payable]\n  pub fn nft_transfer(&mut self, receiver_id: AccountId, token_id: TokenId) -> Promise {\n    let promise = ext_nft_contract::ext(self.nft_contract.clone())\n      .with_attached_deposit(YOCTO_NEAR)\n      .nft_transfer(receiver_id, token_id);\n\n    return promise.then( // Create a promise to callback query_greeting_callback\n      Self::ext(env::current_account_id())\n      .nft_transfer_callback()\n    )\n  }\n\n  #[private] // Public - but only callable by env::current_account_id()\n  pub fn nft_transfer_callback(&self, #[callback_result] call_result: Result<(), PromiseError>) {\n    // Check if the promise succeeded\n    if call_result.is_err() {\n      log!("There was an error contacting NFT contract");\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"list-a-nft-for-sale",children:"List a NFT for sale"}),"\n",(0,r.jsx)(t.p,{children:"Due to the specifics of putting a token up for sale on a NFT marketplace (more precisely, the need for the owner of the token to sign an approval transaction), you need to do this on the client side."}),"\n",(0,r.jsxs)(t.p,{children:["Check out how to do it from a ",(0,r.jsx)(t.a,{href:"/primitives/nft/interacting/bos#list-a-nft-up-for-a-sale",children:"NEAR component"})," or from a ",(0,r.jsx)(t.a,{href:"/primitives/nft/interacting/web-app#list-a-nft-up-for-a-sale",children:"web app"}),"."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"additional-resources",children:"Additional resources"}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsxs)(t.p,{children:["Read more about cross contract calls ",(0,r.jsx)(t.a,{href:"https://docs.near.org/tutorials/examples/xcc",children:"here"}),"."]})}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["Example of ",(0,r.jsx)(t.a,{href:"/develop/relevant-contracts/nft#attaching-nfts-to-a-call",children:"how to attach NFTs to a contract call"}),"."]})})]})}function u(n={}){const{wrapper:t}={...(0,a.a)(),...n.components};return t?(0,r.jsx)(t,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},11151:(n,t,e)=>{e.d(t,{Z:()=>o,a:()=>i});var r=e(67294);const a={},c=r.createContext(a);function i(n){const t=r.useContext(c);return r.useMemo((function(){return"function"==typeof n?n(t):{...t,...n}}),[t,n])}function o(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:i(n.components),r.createElement(c.Provider,{value:t},n.children)}}}]);