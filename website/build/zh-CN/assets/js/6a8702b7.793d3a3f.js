"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4170],{90665:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var r=n(85893),a=n(11151);const s={sidebar_position:2,title:"Private Methods"},i="Private Methods",o={id:"sdk/js/contract-interface/private-methods",title:"Private Methods",description:"When Using Callbacks",source:"@site/i18n/zh-CN/docusaurus-plugin-content-docs/current/sdk/js/contract-interface/private-methods.md",sourceDirName:"sdk/js/contract-interface",slug:"/sdk/js/contract-interface/private-methods",permalink:"/zh-CN/sdk/js/contract-interface/private-methods",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/sdk/js/contract-interface/private-methods.md",tags:[],version:"current",lastUpdatedBy:"Github Actions",lastUpdatedAt:1718378911e3,sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Private Methods"},sidebar:"tools",previous:{title:"Public Methods",permalink:"/zh-CN/sdk/js/contract-interface/public-methods"},next:{title:"Payable Methods",permalink:"/zh-CN/sdk/js/contract-interface/payable-methods"}},c={},l=[{value:"When Using Callbacks",id:"when-using-callbacks",level:2},{value:"Writing Internal Methods",id:"writing-internal-methods",level:2}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"private-methods",children:"Private Methods"}),"\n",(0,r.jsx)(t.h2,{id:"when-using-callbacks",children:"When Using Callbacks"}),"\n",(0,r.jsxs)(t.p,{children:["Usually, when a contract has to have a callback for a remote cross-contract call, this callback method should only be called by the contract itself to avoid someone else calling it and changing the state. A common pattern is to have an assertion that validates that the direct caller (predecessor account ID) matches to the contract's account (current account ID). The ",(0,r.jsx)(t.code,{children:"({ privateFunction: true })"})," decorator simplifies this by making it a single line decorator while improving readability. A common pattern is to have an assertion that validates that the direct caller (predecessor account ID) matches to the contract's account (current account ID). The ",(0,r.jsx)(t.code,{children:"({ privateFunction: true })"})," decorator simplifies this by making it a single line decorator while improving readability."]}),"\n",(0,r.jsxs)(t.p,{children:["Use this annotation within the designated contract class with the ",(0,r.jsxs)(t.a,{href:"/zh-CN/sdk/js/contract-structure/near-bindgen",children:[(0,r.jsx)(t.code,{children:"NearBindgen({})"})," decorator"]})," as follows:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"@call({ privateFunction: true })\nmy_method({}) {\n    // ...\n}\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Which is equivalent to:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'@call({})\nmy_method({}) {\n    if near.currentAccountId() != near.predecessorAccountId() {\n        throw new Error("Method method is private");\n    }\n    // ...\n}\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"Now with this annotation, only the account of the contract itself can call this method, either directly or through a promise."}),"\n",(0,r.jsx)(t.h2,{id:"writing-internal-methods",children:"Writing Internal Methods"}),"\n",(0,r.jsx)(t.p,{children:"Not all functions need to be exposed publicly. It may be beneficial to write private methods for helper or utility functions, for instance. There are three approaches to write internal methods: It may be beneficial to write private methods for helper or utility functions, for instance. There are three approaches to write internal methods:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["Declare the method without using the ",(0,r.jsx)(t.code,{children:"call"})," or ",(0,r.jsx)(t.code,{children:"view"})," decorators."]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"helperMethod(a, b) {\n  // ...\n}\n}\n"})}),"\n",(0,r.jsxs)(t.ol,{start:"2",children:["\n",(0,r.jsx)(t.li,{children:"Using an internal helper function in the module scope."}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"// Function that can be called in another JS file\nfunction getFirstName(account) {\n  // ...\n}\n}\n"})}),"\n",(0,r.jsxs)(t.ol,{start:"3",children:["\n",(0,r.jsx)(t.li,{children:"Importing a helper function or class from another module."}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Another way of not exporting methods is by having a separate class, that is not marked with ",(0,r.jsx)(t.code,{children:"NearBindgen({})"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'import { getFirstName } from "./helpers.js";\n\n@NearBindgen({})\nexport class Contract {\n  // ...\n}\n\nclass Helpers {\n  // ...\n}\n}\n\nclass Helpers {\n  // ...\n}\n'})})]})}function d(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>i});var r=n(67294);const a={},s=r.createContext(a);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);