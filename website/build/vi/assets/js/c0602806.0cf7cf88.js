"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8633],{6127:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var a=t(85893),r=t(11151);const s={id:"smart-contract",title:"Smart Contract",hide_table_of_contents:!1},i=void 0,c={id:"primitives/ft/interacting/smart-contract",title:"Smart Contract",description:"This section will explain how a smart contract can handle a deposit in FTs, send tokens, swap tokens and attach them to call.",source:"@site/i18n/vi/docusaurus-plugin-content-docs/current/7.primitives/ft/interacting/smart-contract.md",sourceDirName:"7.primitives/ft/interacting",slug:"/primitives/ft/interacting/smart-contract",permalink:"/vi/primitives/ft/interacting/smart-contract",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/7.primitives/ft/interacting/smart-contract.md",tags:[],version:"current",lastUpdatedBy:"Github Actions",lastUpdatedAt:1704996595,formattedLastUpdatedAt:"11 thg 1, 2024",frontMatter:{id:"smart-contract",title:"Smart Contract",hide_table_of_contents:!1},sidebar:"primitives",previous:{title:"Web Application",permalink:"/vi/primitives/ft/interacting/web-app"},next:{title:"NEAR CLI",permalink:"/vi/primitives/ft/interacting/near-cli"}},o={},l=[{value:"Base Contract",id:"base-contract",level:3},{value:"Handle a deposit",id:"handle-a-deposit",level:2},{value:"Send tokens",id:"send-tokens",level:2},{value:"Attaching FTs to a Call",id:"attaching-fts-to-a-call",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"This section will explain how a smart contract can handle a deposit in FTs, send tokens, swap tokens and attach them to call."}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["If you are looking to create your own FT contract please check the ",(0,a.jsx)(n.a,{href:"https://github.com/near-examples/FT",children:"Example implementation"})," and the ",(0,a.jsx)(n.a,{href:"https://docs.near.org/tutorials/fts/introduction",children:"FT Zero to Hero Tutorial"})]})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"base-contract",children:"Base Contract"}),"\n",(0,a.jsx)(n.p,{children:"The examples assume that the contract is defined as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;\nuse near_contract_standards::fungible_token::core::ext_ft_core::ext;\nuse near_sdk::ext_contract;\nuse near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::json_types::U128;\nuse near_sdk::serde::{Deserialize, Serialize};\nuse near_sdk::{env, near_bindgen, serde_json, log, Gas, AccountId, Promise, PromiseOrValue, PromiseError};\n\nconst FT_CONTRACT: &str = "token-v3.cheddar.testnet";\n\nconst PRICE: u128 = 100_000_000_000_000_000_000_000;\nconst YOCTO_NEAR: u128 = 1;\nconst TGAS: u64 = 1_000_000_000_000;\n\n// Define the contract structure\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct Contract {\n  ft_contract: AccountId,\n  price: U128\n}\n\nimpl Default for Contract {\n    // The default trait with which to initialize the contract\n    fn default() -> Self {\n        Self {\n          ft_contract: FT_CONTRACT.parse().unwrap(),\n          price: U128(PRICE),\n        }\n    }\n}\n\n// Message parameters to receive via token function call.\n#[derive(Serialize, Deserialize)]\n#[serde(crate = "near_sdk::serde")]\n#[serde(untagged)]\nenum TokenReceiverMessage {\n  Action {\n    // Parameters which you want to get in msg object, e.g. buyer_id\n    buyer_id: Option<AccountId>,\n  },\n}\n\n// Implement the contract structure\n#[near_bindgen]\nimpl Contract {}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"handle-a-deposit",children:"Handle a deposit"}),"\n",(0,a.jsxs)(n.p,{children:["If you want your contract to handle deposit in FTs you have to implement the ",(0,a.jsx)(n.code,{children:"ft_on_transfer"})," method. When executed, such method will know:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Which FT was transferred, since it is the predecessor account."}),"\n",(0,a.jsx)(n.li,{children:"Who is sending the FT, since it is a parameter"}),"\n",(0,a.jsx)(n.li,{children:"How many FT were transferred, since it is a parameter"}),"\n",(0,a.jsx)(n.li,{children:"If there are any parameters encoded as a message"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"ft_on_transfer"})," must return how many FT tokens have to ",(0,a.jsx)(n.strong,{children:"be refunded"}),", so the FT contract gives them back to the sender."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'// Implement the contract structure\n#[near_bindgen]\nimpl Contract {}\n\n#[near_bindgen]\nimpl FungibleTokenReceiver for Contract {\n  // Callback on receiving tokens by this contract.\n  // `msg` format is either "" for deposit or `TokenReceiverMessage`.\n  fn ft_on_transfer(\n    &mut self,\n    sender_id: AccountId,\n    amount: U128,\n    msg: String,\n  ) -> PromiseOrValue<U128> {\n    let token_in = env::predecessor_account_id();\n\n    assert!(token_in == self.ft_contract, "{}", "The token is not supported");\n    assert!(amount >= self.price, "{}", "The attached amount is not enough");\n\n    env::log_str(format!("Sender id: {:?}", sender_id).as_str());\n\n    if msg.is_empty() {\n      // Your internal logic here\n      PromiseOrValue::Value(U128(0))\n    } else {\n      let message =\n        serde_json::from_str::<TokenReceiverMessage>(&msg).expect("WRONG_MSG_FORMAT");\n      match message {\n        TokenReceiverMessage::Action {\n          buyer_id,\n        } => {\n          let buyer_id = buyer_id.map(|x| x.to_string());\n          env::log_str(format!("Target buyer id: {:?}", buyer_id).as_str());\n          // Your internal business logic\n          PromiseOrValue::Value(U128(0))\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"send-tokens",children:"Send tokens"}),"\n",(0,a.jsx)(n.p,{children:"This snippet assumes that the contract is already holding some FTs and that you want to send them to another account."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[near_bindgen]\nimpl Contract {\n  #[payable]\n  pub fn send_tokens(&mut self, receiver_id: AccountId, amount: U128) -> Promise {\n    assert_eq!(env::attached_deposit(), 1, "Requires attached deposit of exactly 1 yoctoNEAR");\n\n    let promise = ext(self.ft_contract.clone())\n      .with_attached_deposit(YOCTO_NEAR)\n      .ft_transfer(receiver_id, amount, None);\n\n    return promise.then( // Create a promise to callback query_greeting_callback\n      Self::ext(env::current_account_id())\n      .with_static_gas(Gas(30*TGAS))\n      .external_call_callback()\n    )\n  }\n\n  #[private] // Public - but only callable by env::current_account_id()\n  pub fn external_call_callback(&self, #[callback_result] call_result: Result<(), PromiseError>) {\n    // Check if the promise succeeded\n    if call_result.is_err() {\n      log!("There was an error contacting external contract");\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"attaching-fts-to-a-call",children:"Attaching FTs to a Call"}),"\n",(0,a.jsx)(n.p,{children:"Natively, only NEAR tokens (\u24c3) can be attached to a method calls. However, the FT standard enables to attach fungible tokens in a call by using the FT-contract as intermediary. This means that, instead of you attaching tokens directly to the call, you ask the FT-contract to do both a transfer and a method call in your name."}),"\n",(0,a.jsx)(n.p,{children:"Let's assume that you need to deposit FTs on Ref Finance."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[payable]\npub fn call_with_attached_tokens(&mut self, receiver_id: AccountId, amount: U128) -> Promise {\n  assert_eq!(env::attached_deposit(), 1, "Requires attached deposit of exactly 1 yoctoNEAR");\n\n  let promise = ext(self.ft_contract.clone())\n    .with_static_gas(Gas(150*TGAS))\n    .with_attached_deposit(YOCTO_NEAR)\n    .ft_transfer_call(receiver_id, amount, None, "".to_string());\n\n  return promise.then( // Create a promise to callback query_greeting_callback\n    Self::ext(env::current_account_id())\n    .with_static_gas(Gas(100*TGAS))\n    .external_call_callback()\n  )\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"How it works:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"You call ft_transfer_call in the FT contract passing: the receiver, a message, and the amount."}),"\n",(0,a.jsx)(n.li,{children:"The FT contract transfers the amount to the receiver (in this case Ref finance)."}),"\n",(0,a.jsx)(n.li,{children:"The FT contract calls receiver.ft_on_transfer(sender, msg, amount)"}),"\n",(0,a.jsx)(n.li,{children:"The FT contract handles errors in the ft_resolve_transfer callback."}),"\n",(0,a.jsx)(n.li,{children:"The FT contract returns you how much of the attached amount was actually used."}),"\n"]}),"\n",(0,a.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>i});var a=t(67294);const r={},s=a.createContext(r);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);