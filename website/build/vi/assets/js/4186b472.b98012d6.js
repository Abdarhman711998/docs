"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6630],{3125:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var i=t(85893),o=t(11151);const s={id:"hype-indexer",title:"Hype Indexer",sidebar_label:"Hype Indexer"},c=void 0,a={id:"tutorials/near-components/indexer-tutorials/hype-indexer",title:"Hype Indexer",description:"This tutorial creates a blockchain indexer using NEAR QueryAPI.",source:"@site/i18n/vi/docusaurus-plugin-content-docs/current/3.tutorials/near-components/indexer-tutorials/hype-indexer.md",sourceDirName:"3.tutorials/near-components/indexer-tutorials",slug:"/tutorials/near-components/indexer-tutorials/hype-indexer",permalink:"/vi/tutorials/near-components/indexer-tutorials/hype-indexer",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/3.tutorials/near-components/indexer-tutorials/hype-indexer.md",tags:[],version:"current",lastUpdatedBy:"Github Actions",lastUpdatedAt:1720430471e3,frontMatter:{id:"hype-indexer",title:"Hype Indexer",sidebar_label:"Hype Indexer"},sidebar:"tutorials",previous:{title:"Posts Indexer",permalink:"/vi/tutorials/near-components/indexer-tutorials/posts-indexer"},next:{title:"NFTs Indexer",permalink:"/vi/tutorials/near-components/indexer-tutorials/nft-indexer"}},r={},d=[{value:"Overview",id:"overview",level:2},{value:"Defining the Database Schema",id:"defining-the-database-schema",level:2},{value:"Defining the indexing logic",id:"defining-the-indexing-logic",level:2},{value:"Filtering Blockchain transactions",id:"filtering-blockchain-transactions",level:3},{value:"Saving the data to the Database",id:"saving-the-data-to-the-database",level:3},{value:"<code>createPost</code>",id:"createpost",level:4},{value:"<code>createComment</code>",id:"createcomment",level:4},{value:"Querying data from the indexer",id:"querying-data-from-the-indexer",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This tutorial creates a blockchain indexer using ",(0,i.jsx)(n.a,{href:"/vi/build/data-infrastructure/query-api/intro",children:"NEAR QueryAPI"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:["This indexer creates a new row in a pre-defined ",(0,i.jsx)(n.code,{children:"posts"})," or ",(0,i.jsx)(n.code,{children:"comments"}),' table created by the user in the GraphQL database for every new post or comment found on the blockchain that contains either "PEPE" or "DOGE" in the contents. This is a simple example that shows how to specify two tables, filter blockchain transaction data for a specific type of transaction and its contents, and save the data to the database.']}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This indexer can be found by ",(0,i.jsx)(n.a,{href:"https://dev.near.org/#/dataplatform.near/widget/QueryApi.App?selectedIndexerPath=bucanero.near/hype-indexer",children:"following this link"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"defining-the-database-schema",children:"Defining the Database Schema"}),"\n",(0,i.jsxs)(n.p,{children:["The first step to creating an indexer is to define the database schema. This is done by editing the ",(0,i.jsx)(n.code,{children:"schema.sql"})," file in the code editor. The schema for this indexer looks like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE\n  "posts" (\n    "id" TEXT NOT NULL,\n    "account_id" VARCHAR NOT NULL,\n    "block_height" DECIMAL(58, 0) NOT NULL,\n    "block_timestamp" DECIMAL(20, 0) NOT NULL,\n    "receipt_id" VARCHAR NOT NULL,\n    "content" TEXT NOT NULL,\n    CONSTRAINT "posts_pkey" PRIMARY KEY ("id")\n  );\n\nCREATE TABLE\n  "comments" (\n    "id" SERIAL NOT NULL,\n    "post_id" TEXT NOT NULL,\n    "account_id" VARCHAR NOT NULL,\n    "block_height" DECIMAL(58, 0) NOT NULL,\n    "block_timestamp" DECIMAL(20, 0) NOT NULL,\n    "receipt_id" VARCHAR NOT NULL,\n    "content" TEXT NOT NULL,\n    CONSTRAINT "comments_pkey" PRIMARY KEY ("id")\n  );\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This schema defines two tables: ",(0,i.jsx)(n.code,{children:"posts"})," and ",(0,i.jsx)(n.code,{children:"comments"}),". The ",(0,i.jsx)(n.code,{children:"posts"})," table has columns:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"id"}),": a unique identifier for each row in the table"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"account_id"}),": the account ID of the user who created the post"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"block_height"}),": the height of the block in which the post was created"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"block_timestamp"}),": the timestamp of the block in which the post was created"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"receipt_id"}),": the receipt ID of the transaction that created the post"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"content"}),": the content of the post"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"comments"})," table has columns:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"id"}),": a unique identifier for each row in the table"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"post_id"}),": the ID of the post that the comment was made on"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"account_id"}),": the account ID of the user who created the comment"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"block_height"}),": the height of the block in which the comment was created"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"block_timestamp"}),": the timestamp of the block in which the comment was created"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"receipt_id"}),": the receipt ID of the transaction that created the comment"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"content"}),": the content of the comment"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"defining-the-indexing-logic",children:"Defining the indexing logic"}),"\n",(0,i.jsxs)(n.p,{children:["The next step is to define the indexing logic. This is done by editing the ",(0,i.jsx)(n.code,{children:"indexingLogic.js"})," file in the code editor. The logic for this indexer can be divided into two parts:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Filtering blockchain transactions for a specific type of transaction"}),"\n",(0,i.jsx)(n.li,{children:"Saving the data from the filtered transactions to the database"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"filtering-blockchain-transactions",children:"Filtering Blockchain transactions"}),"\n",(0,i.jsxs)(n.p,{children:["The first part of the logic is to filter blockchain transactions for a specific type of transaction. This is done by using the ",(0,i.jsx)(n.code,{children:"getBlock"})," function. This function takes in a block and a context and returns a promise. The block is a Near Protocol block, and the context is a set of helper methods to retrieve and commit state. The ",(0,i.jsx)(n.code,{children:"getBlock"})," function is called for every block on the blockchain."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"getBlock"})," function for this indexer looks like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'import { Block } from "@near-lake/primitives";\n\nasync function getBlock(block: Block, context) {\n  const SOCIAL_DB = "social.near";\n\n  function base64decode(encodedValue) {\n    let buff = Buffer.from(encodedValue, "base64");\n    return JSON.parse(buff.toString("utf-8"));\n  }\n\n  function get_near_social_posts_comments(\n    block_type = block,\n    DB = SOCIAL_DB,\n    decodeFunction = base64decode\n  ) {\n    const nearSocialPostsComments = block_type\n      .actions()\n      .filter((action) => action.receiverId === DB)\n      .flatMap((action) =>\n        action.operations\n          .map((operation) => operation["FunctionCall"])\n          .filter((operation) => operation?.methodName === "set")\n          .map((functionCallOperation) => ({\n            ...functionCallOperation,\n            args: decodeFunction(functionCallOperation.args),\n            receiptId: action.receiptId, // providing receiptId as we need it\n          }))\n          .filter((functionCall) => {\n            const accountId = Object.keys(functionCall.args.data)[0];\n            return (\n              Object.keys(functionCall.args.data[accountId]).includes("post") ||\n              Object.keys(functionCall.args.data[accountId]).includes("index")\n            );\n          })\n      );\n    return nearSocialPostsComments;\n  }\n\n  const nearSocialPostsComments = get_near_social_posts_comments();\n\n  ... // Further filtering for posts/comments that contain "PEPE" or "DOGE" in the contents and saving the data to the database is done in the next section\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Again, like with the ",(0,i.jsx)(n.a,{href:"/vi/tutorials/near-components/indexer-tutorials/posts-indexer",children:(0,i.jsx)(n.code,{children:"posts-indexer"})})," or the ",(0,i.jsx)(n.a,{href:"/vi/tutorials/near-components/indexer-tutorials/feed-indexer",children:(0,i.jsx)(n.code,{children:"feed-indexer"})}),", this filter selects transactions that are of type ",(0,i.jsx)(n.code,{children:"FunctionCall"})," to the ",(0,i.jsx)(n.code,{children:"set"})," method on the contract ",(0,i.jsx)(n.code,{children:"social.near"})," on the network. In addition, it searches for ",(0,i.jsx)(n.code,{children:"post"})," or ",(0,i.jsx)(n.code,{children:"index"})," string in the data for the call."]}),"\n",(0,i.jsx)(n.h3,{id:"saving-the-data-to-the-database",children:"Saving the data to the Database"}),"\n",(0,i.jsx)(n.p,{children:'The second part of the logic is to save the data from the filtered transactions to the database. This section also performs the filtering of transactions for posts and comments that contain "PEPE" or "DOGE" in the contents.'}),"\n",(0,i.jsx)(n.p,{children:"The logic for this looks like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'  ... // Logic for filtering blockchain transactions is above\n\n  if (nearSocialPostsComments.length > 0) {\n    const blockHeight = block.blockHeight;\n    const blockTimestamp = Number(block.header().timestampNanosec);\n    await Promise.all(\n      nearSocialPostsComments.map(async (postAction) => {\n        const accountId = Object.keys(postAction.args.data)[0];\n        console.log(`ACCOUNT_ID: ${accountId}`);\n\n        const isPost =\n          postAction.args.data[accountId].post &&\n          Object.keys(postAction.args.data[accountId].post).includes("main");\n        const isComment =\n          postAction.args.data[accountId].post &&\n          Object.keys(postAction.args.data[accountId].post).includes("comment");\n\n        if (isPost) {\n          const isHypePost =\n            postAction.args.data[accountId].post.main.includes("PEPE") ||\n            postAction.args.data[accountId].post.main.includes("DOGE");\n          if (!isHypePost) {\n            return;\n          }\n          console.log("Creating a post...");\n          const postId = `${accountId}:${blockHeight}`;\n          await createPost(\n            postId,\n            accountId,\n            blockHeight,\n            blockTimestamp,\n            postAction.receiptId,\n            postAction.args.data[accountId].post.main\n          );\n        }\n        if (isComment) {\n          const commentString = JSON.parse(\n            postAction.args.data[accountId].post.comment\n          );\n          const isHypeComment =\n            commentString.includes("PEPE") || commentString.includes("DOGE");\n          if (!isHypeComment) {\n            return;\n          }\n          console.log("Creating a comment...");\n          const postBlockHeight =\n            postAction.args.data[accountId].post.blockHeight;\n          const postId = `${accountId}:${postBlockHeight}`;\n          await createComment(\n            accountId,\n            postId,\n            blockHeight,\n            blockTimestamp,\n            postAction.receiptId,\n            commentString\n          );\n        }\n      })\n    );\n  }\n\n  ... // Definitions for createPost and createComment are below\n'})}),"\n",(0,i.jsx)(n.h4,{id:"createpost",children:(0,i.jsx)(n.code,{children:"createPost"})}),"\n",(0,i.jsxs)(n.p,{children:["Creating a post is done by using the ",(0,i.jsx)(n.a,{href:"/vi/build/data-infrastructure/query-api/context-object#insert",children:(0,i.jsx)(n.code,{children:"context.db.Posts.insert()"})})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'  async function createPost(\n    postId,\n    accountId,\n    blockHeight,\n    blockTimestamp,\n    receiptId,\n    postContent\n  ) {\n    try {\n      const postObject = {\n          id: postId,\n          account_id: accountId,\n          block_height: blockHeight,\n          block_timestamp: blockTimestamp,\n          receipt_id: receiptId,\n          content: postContent,\n      };\n      await context.db.Posts.insert(postObject);\n      console.log("Post created!");\n    } catch (error) {\n      console.error(error);\n    }\n  }\n'})}),"\n",(0,i.jsx)(n.h4,{id:"createcomment",children:(0,i.jsx)(n.code,{children:"createComment"})}),"\n",(0,i.jsxs)(n.p,{children:["Creating a comment is done by using the ",(0,i.jsx)(n.a,{href:"/vi/build/data-infrastructure/query-api/context-object#insert",children:(0,i.jsx)(n.code,{children:"context.db.Comments.insert()"})})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'  async function createComment(\n    accountId,\n    postId,\n    blockHeight,\n    blockTimestamp,\n    receiptId,\n    commentContent\n  ) {\n    try {\n      const commentObject = {\n          account_id: accountId,\n          post_id: postId,\n          block_height: blockHeight,\n          block_timestamp: blockTimestamp,\n          receipt_id: receiptId,\n          content: commentContent,\n      };\n      await context.db.Comments.insert(commentObject);\n      console.log("Comment created!");\n    } catch (error) {\n      console.error(error);\n    }\n  }\n'})}),"\n",(0,i.jsx)(n.h2,{id:"querying-data-from-the-indexer",children:"Querying data from the indexer"}),"\n",(0,i.jsx)(n.p,{children:"The final step is querying the indexer using the public GraphQL API. This can be done by writing a GraphQL query using the GraphiQL tab in the code editor."}),"\n",(0,i.jsxs)(n.p,{children:["For example, here's a query that fetches ",(0,i.jsx)(n.code,{children:"posts"})," and ",(0,i.jsx)(n.code,{children:"comments"})," from the ",(0,i.jsx)(n.em,{children:"Hype Indexer"}),", ordered by ",(0,i.jsx)(n.code,{children:"block_height"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"query MyQuery {\n  <user-name>_near_hype_indexer_posts(order_by: {block_height: desc}) {\n    account_id\n    block_height\n    content\n  }\n  <user-name>_near_hype_indexer_comments(order_by: {block_height: desc}) {\n    account_id\n    block_height\n    content\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Once you have defined your query, you can use the GraphiQL Code Exporter to auto-generate a JavaScript or NEAR Widget code snippet. The exporter will create a helper method ",(0,i.jsx)(n.code,{children:"fetchGraphQL"})," which will allow you to fetch data from the indexer's GraphQL API. It takes three parameters:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"operationsDoc"}),": A string containing the queries you would like to execute."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"operationName"}),": The specific query you want to run."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"variables"}),": Any variables to pass in that your query supports, such as ",(0,i.jsx)(n.code,{children:"offset"})," and ",(0,i.jsx)(n.code,{children:"limit"})," for pagination."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Next, you can call the ",(0,i.jsx)(n.code,{children:"fetchGraphQL"})," function with the appropriate parameters and process the results."]}),"\n",(0,i.jsxs)(n.p,{children:["Here's the complete code snippet for a NEAR component using the ",(0,i.jsx)(n.em,{children:"Hype Indexer"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const QUERYAPI_ENDPOINT = `https://near-queryapi.api.pagoda.co/v1/graphql/`;\n\nState.init({\ndata: []\n});\n\nconst query = `query MyHypeQuery {\n    <user-name>_near_hype_indexer_posts(order_by: {block_height: desc}) {\n      account_id\n      block_height\n      content\n    }\n    <user-name>_near_hype_indexer_comments(order_by: {block_height: desc}) {\n      account_id\n      block_height\n      content\n    }\n  }`\n\nfunction fetchGraphQL(operationsDoc, operationName, variables) {\n      return asyncFetch(\n        QUERYAPI_ENDPOINT,\n        {\n          method: "POST",\n          headers: { "x-hasura-role": `<user-name>_near` },\n          body: JSON.stringify({\n            query: operationsDoc,\n            variables: variables,\n            operationName: operationName,\n          }),\n        }\n      );\n    }\n\nfetchGraphQL(query, "MyHypeQuery", {}).then((result) => {\n  if (result.status === 200) {\n    if (result.body.data) {\n      const data = result.body.data.<user-name>_near_hype_indexer_posts;\n      State.update({ data })\n      console.log(data);\n    }\n  }\n});\n\nconst renderData = (a) => {\n  return (\n    <div key={JSON.stringify(a)}>\n        {JSON.stringify(a)}\n    </div>\n  );\n};\n\nconst renderedData = state.data.map(renderData);\nreturn (\n  {renderedData}\n);\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["To view a more complex example, see this widget which fetches posts with proper pagination: ",(0,i.jsx)(n.a,{href:"https://dev.near.org/edit/roshaan.near/widget/query-api-feed-infinite",children:"Posts Widget powered By QueryAPI"}),"."]})})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>c});var i=t(67294);const o={},s=i.createContext(o);function c(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);